.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "COLLECTD-UNIXSOCK 5"
.TH COLLECTD-UNIXSOCK 5 "2007-10-27" "4.2.0" "collectd"
.SH "NAME"
collectd\-unixsock \- Documentation of collectd's \f(CW\*(C`unixsock plugin\*(C'\fR
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 8
\&  # See collectd.conf(5)
\&  LoadPlugin unixsock
\&  # ...
\&  <Plugin unixsock>
\&    SocketFile "/path/to/socket"
\&    SocketGroup "collectd"
\&    SocketPerms "0770"
\&  </Plugin>
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \f(CW\*(C`unixsock plugin\*(C'\fR opens an UNIX-socket over which one can interact with
the daemon. This can be used to use the values collected by collectd in other
applications, such as monitoring, or submit externally collected values to
collectd.
.PP
This plugin is used by \fIcollectd\-nagios\fR\|(1) to check if some value is in a
certain range and exit with a Nagios-compatible exit code.
.SH "COMMANDS"
.IX Header "COMMANDS"
Upon start the \f(CW\*(C`unixsock plugin\*(C'\fR opens a UNIX-socket and waits for
connections. Once a connection is established the client can send commands to
the daemon which it will answer, if it understand them.
.PP
The following commands are implemented:
.IP "\fB\s-1GETVAL\s0\fR \fIIdentifier\fR" 4
.IX Item "GETVAL Identifier"
If the value identified by \fIIdentifier\fR (see below) is found the complete
value-list is returned. The response is a space separated list of
name\-value\-pairs:
.Sp
\&\fInum\fR \fIname\fR\fB=\fR\fIvalue\fR[ \fIname\fR\fB=\fR\fIvalue\fR[ ...]]
.Sp
If \fInum\fR is less then zero, an error occurred. Otherwise it contains the
number of values that follow. Each value is of the form \fIname\fR\fB=\fR\fIvalue\fR.
Counter-values are converted to a rate, e.\ g. bytes per second.
Undefined values are returned as \fBNaN\fR.
.Sp
Example:
  \-> | \s-1GETVAL\s0 myhost/cpu\-0/cpu\-user
  <\- | 1 value=1.260000e+00
.IP "\fB\s-1LISTVAL\s0\fR" 4
.IX Item "LISTVAL"
Returns a list of the values available in the value cache together with the
time of the last update, so that querying applications can issue a \fB\s-1GETVAL\s0\fR
command for the values that have changed.
.Sp
The first line's status number is the number of identifiers returned or less
than zero if an error occurred. Each of the following lines contains the
update time as an epoch value and the identifier, separated by a space.
.Sp
Example:
  \-> | \s-1LISTVAL\s0
  <\- | 69 Values found
  <\- | 1182204284 leeloo/cpu\-0/cpu\-idle
  <\- | 1182204284 leeloo/cpu\-0/cpu\-nice
  <\- | 1182204284 leeloo/cpu\-0/cpu\-system
  <\- | 1182204284 leeloo/cpu\-0/cpu\-user
  ...
.IP "\fB\s-1PUTVAL\s0\fR \fIIdentifier\fR [\fIOptionList\fR] \fIValuelist\fR" 4
.IX Item "PUTVAL Identifier [OptionList] Valuelist"
Submits one or more values (identified by \fIIdentifier\fR, see below) to the
daemon which will dispatch it to all it's write\-plugins.
.Sp
An \fIIdentifier\fR is of the form
\&\f(CW\*(C`\f(CIhost\f(CW\f(CB/\f(CW\f(CIplugin\f(CW\f(CB\-\f(CW\f(CIinstance\f(CW\f(CB/\f(CW\f(CItype\f(CW\f(CB\-\f(CW\f(CIinstance\f(CW\*(C'\fR with both
\&\fIinstance\fR\-parts being optional. If they're omitted the hyphen must be
omitted, too.
.Sp
The \fIOptionList\fR is an optional list of \fIOptions\fR, where each option if a
key\-value\-pair. A list of currently understood options can be found below, all
other options will be ignored.
.Sp
\&\fIValuelist\fR is a colon-separated list of the time and the values, each either
an integer if the data-source is a counter, of a double if the data-source if
of type \*(L"gauge\*(R". You can submit an undefined gauge-value by using \fBU\fR. When
submitting \fBU\fR to a counter the behavior is undefined. The time is given as
epoch (i.\ e. standard \s-1UNIX\s0 time).
.Sp
You can mix options and values, but the order is important: Options only
effect following values, so specifying an option as last field is allowed, but
useless. Also, an option applies to \fBall\fR following values, so you don't need
to re-set an option over and over again.
.Sp
The currently defined \fBOptions\fR are:
.RS 4
.IP "\fBinterval=\fR\fIseconds\fR" 4
.IX Item "interval=seconds"
Gives the interval in which the data identified by \fIIdentifier\fR is being
collected.
.RE
.RS 4
.Sp
Please note that this is the same format as used in the \fBexec plugin\fR, see
\&\fIcollectd\-exec\fR\|(5).
.Sp
Example:
  \-> | \s-1PUTVAL\s0 testhost/interface/if_octets\-test0 interval=10 1179574444:123:456
  <\- | 0 Success
.RE
.Sh "Identifiers"
.IX Subsection "Identifiers"
Value or value-lists are identified in a uniform fashion:
.PP
\&\fIHostname\fR/\fIPlugin\fR/\fIType\fR
.PP
Where \fIPlugin\fR and \fIType\fR are both either of type "\fIName\fR\*(L" or
\&\*(R"\fIName\fR\-\fIInstance\fR". This sounds more complicated than it is, so here are
some examples:
.PP
.Vb 4
\&  myhost/cpu\-0/cpu\-user
\&  myhost/load/load
\&  myhost/memory/memory\-used
\&  myhost/disk\-sda/disk_octets
.Ve
.Sh "Return values"
.IX Subsection "Return values"
Unless otherwise noted the plugin answers with a line of the following form:
.PP
\&\fINum\fR \fIMessage\fR
.PP
If \fINum\fR is zero the message indicates success, if \fINum\fR is non-zero the
message indicates failure. \fIMessage\fR is a human-readable string that describes
the return value further.
.PP
Commands that return values may use \fINum\fR to return the number of values that
follow, such as the \fB\s-1GETVAL\s0\fR command. These commands usually return a negative
value on failure and never return zero.
.SH "ABSTRACTION LAYER"
.IX Header "ABSTRACTION LAYER"
Shipped with the sourcecode comes the Perl-Module Collectd::Unixsock which
provides an abstraction layer over the actual socket connection. It can be
found in the directory \fIcontrib/PerlLib\fR. If you want to use Perl to
communicate with the daemon, you're encouraged to use and expand this module.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIcollectd\fR\|(1),
\&\fIcollectd.conf\fR\|(5),
\&\fIcollectd\-nagios\fR\|(1),
\&\fIunix\fR\|(7)
.SH "AUTHOR"
.IX Header "AUTHOR"
Florian Forster <octo@verplant.org>
